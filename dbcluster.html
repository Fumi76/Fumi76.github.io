<html>
<head>
    <meta charset="utf-8" />
    <link rel="stylesheet" type="text/css" href="css/style.css" />
</head>
<body>
<div style="width: 100%;" align="center">
<div style="margin-top: 20px; width: 80%; text-align: left;">

<h1>Auroraメモ</h1>
    <h2>DBクラスター</h2>
<ul>
    <li>DBクラスターは1つ以上のDBインスタンスとそのデータを管理する1つのクラスターボリュームから構成される。計算（DBエンジン?)とストレージを分割している。</li>
    <li>クラスターボリュームは複数のAZにまたがった仮想的なDBストレージボリュームであり、個々のAZそれぞれがDBクラスターのデータのコピーを1つずつ持っている。</li>
    <li>DBインスタンスの種類にはプライマリDBインスタンスとレプリカの2つがある</li>
</ul>

    <h3>プライマリDBインスタンス</h3>
    <ul>
        <li>プライマリDBインスタンスはDBクラスターに1つだけある</li>
        <li>読み書き処理とクラスターボリュームへのデータ操作すべてを担当する</li>
    </ul>

    <h3>レプリカ</h3>
    <ul>
        <li>レプリカは読み取り処理のみサポート。読み取り処理の負荷分散に使用できる（レプリカラグに注意）</li>
        <li>最大15個まで追加できる</li>
        <li>プライマリDBインスタンスが使用不能になった場合に、Auroraは自動的にレプリカにフェイルオーバーする。</li>
        <li>レプリカをプライマリDBインスタンスと別のAZに配置しておくことでプライマリDBインスタンスのいるAZの障害時にも対応できる。</li>
        <li>レプリカにフェイルオーバーの優先順位を設定できる</li>
</ul>

    <h3>クラスターボリューム</h3>
    <ul>
        <li>SSDを使用</li>
        <li>1つのリージョン内の複数AZにデータを自動的に複製する。データの堅牢性、DBの可用性が高まる</li>
        <li>複製の数はクラスタのDBインスタンスの数とは関係しない</li>
        <li>DBインスタンスが1つであっても、(その数とは関係なく)基盤となるストレージボリュームは複数のAZにまたがって配置されている複数のストレージノードから構成される</li>
        <li>クラスターボリュームにはユーザーのすべてのデータ、スキーマオブジェクト、システムテーブルやバイナリログといった内部的なメタデータが格納される。Auroraでは例えば、テーブル、インデクス、BLOB、ストアドプロシージャなどを格納している</li>
        <li>実際のデータ量の増加に応じて自動的に拡張される</li>
        <li>最大64TBまで可能。テーブルの最大サイズも同じ。</li>
        <li>課金は実際に確保している領域に応じてだが、high water mark式のため、データを削除しても確保している領域は減らないので注意</li>
    </ul>

    <h3>Auroraの自動化機能</h3>
    <ul>
        <li>ストレージの自動修復</li>
        <li>キャッシュを自動的に最適に「暖気」</li>
        <li>クラッシュからのリカバリ</li>
    </ul>

    <h4>ストレージの自動修復</h4>
    <ul>
        <li>Auroraはクラスターボリュームを構成するディスクボリュームの障害を自動的に検知する</li>
        <li>ディスクボリュームのセグメントに障害が起きたとき、Auroraはすぐにそのセグメントを修復する。修復するときに、そのセグメントのデータが最新状態に一致するように、他のボリュームのデータを使用する。</li>
        <li>上記によりデータの喪失を回避し、ディスク障害からの復旧のためにポイントインタイムのリストアの必要性を減少させている</li>
    </ul>

    <h4>キャッシュを自動的に最適に「暖気」</h4>
    <ul>
        <li>シャットダウン後や再起動後のDB起動時に、Auroraはバッファプールキャッシュを「暖気」する。Auroraは、インメモリのページキャッシュに保持されている使用頻度の高いクエリが使用するページをバッファプールに事前に読み込む。</li>
        <li>バッファプールの「暖気」が不要になり、パフォーマンス上の利点になる</li>
        <li>AuroraのページキャッシュはDBとは別のプロセス(のメモリ)で管理されていて、それによりページキャッシュはDBとは関係なく存続している</li>
        <li>DB障害後の再起動時には、存続しているページキャッシュの最新の状態を使用してバッファプールは「暖気」されるようになっている</li>
    </ul>

    <h4>クラッシュからのリカバリ</h4>
    <ul>
        <li>Auroraはバイナリログなしでもクラッシュから即座にリカバリし、稼働を続けられるように設計されている</li>
        <li>Auroraは複数のスレッドで並行して非同期的にクラッシュからのリカバリを行い、クラッシュ後すぐに再開し、使用可能になるようにしている</li>
        <li>クラッシュからのリカバリについては<a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/Aurora.Managing.Backups.html#Aurora.Managing.FaultTolerance">このページ</a>も参照</li>
        <li>
            Aurora MySQLでのバイナリログの使用とクラッシュからのリカバリにおける考慮事項
            <ul>
                <li>バイナリログを使用すると、クラッシュ後にバイナリログからリカバリすることをDBインスタンスに強制することになるので、リカバリの時間に直接的に影響する</li>
                <li>使用するバイナリログの種類によってログの量と情報量が異なる。binlog_formatパラメータの指定に応じてログのデータ量が異なる。
                    <ul>
                        <li>ROW  最も多い</li>
                        <li>STATEMENT  最も少ない</li>
                        <li>MIXED  中間。データ整合性とパフォーマンスのバランスが最も良い</li>
                    </ul>
                    リカバリ時にDBインスタンスが処理する必要があるデータが多ければ多いほど、リカバリ時間は増加する
                </li>
                <li>AuroraはDBクラスター内でのデータのレプリケーション、ポイントインタイムのリストア(PITR)にバイナリログを必要としない</li>
                <li>外部へのレプリケーションや外部へのバイナリログストリームのためにバイナリログを必要としないのであれば、binlog_formatパラメータにはOFFを指定して無効化しておくことを推奨。それによりリカバリ時間が減少する</li>
                <li>Auroraのバイナリログとレプリケーションについては<a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/Aurora.Replication.html">このページ</a>も参照</li>
            </ul>
        </li>
    </ul>

</div>
</div>
</body>
</html>